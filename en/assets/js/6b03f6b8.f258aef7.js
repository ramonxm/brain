"use strict";(self.webpackChunkbrain=self.webpackChunkbrain||[]).push([[674],{8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var r=i(6540);const s={},t=r.createContext(s);function l(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(t.Provider,{value:n},e.children)}},8673:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"algorithms/greedy/greedy-index","title":"Greedy Algorithms","description":"Introduction","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/algorithms/greedy/index.md","sourceDirName":"algorithms/greedy","slug":"/algorithms/greedy/index","permalink":"/brain/en/docs/algorithms/greedy/index","draft":false,"unlisted":false,"editUrl":"https://github.com/ramonxm/brain/tree/main/docs/algorithms/greedy/index.md","tags":[],"version":"current","lastUpdatedBy":"Ramon Xavier","lastUpdatedAt":1748915689000,"frontMatter":{"id":"greedy-index","title":"Greedy Algorithms","slug":"/algorithms/greedy/index"}}');var s=i(4848),t=i(8453);const l={id:"greedy-index",title:"Greedy Algorithms",slug:"/algorithms/greedy/index"},o="\ud83d\udd27 Greedy Algorithms",a={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Characteristics",id:"characteristics",level:2},{value:"\u2705 Properties of Greedy Algorithms",id:"-properties-of-greedy-algorithms",level:3},{value:"\ud83c\udfaf When to Use",id:"-when-to-use",level:3},{value:"Classic Greedy Algorithms",id:"classic-greedy-algorithms",level:2},{value:"1. Activity Selection Problem",id:"1-activity-selection-problem",level:3},{value:"2. Huffman Coding",id:"2-huffman-coding",level:3},{value:"3. Fractional Knapsack Problem",id:"3-fractional-knapsack-problem",level:3},{value:"General Structure",id:"general-structure",level:2},{value:"Advantages and Disadvantages",id:"advantages-and-disadvantages",level:2},{value:"\u2705 Advantages",id:"-advantages",level:3},{value:"\u274c Disadvantages",id:"-disadvantages",level:3},{value:"Differences from Other Paradigms",id:"differences-from-other-paradigms",level:2},{value:"Simple Example: Change Making",id:"simple-example-change-making",level:2},{value:"\ud83c\udfaf Tips for Solving Greedy Problems",id:"-tips-for-solving-greedy-problems",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"-greedy-algorithms",children:"\ud83d\udd27 Greedy Algorithms"})}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Greedy Algorithms"})," make the locally optimal choice at each step with the hope of finding a global optimum. At every stage, the algorithm picks the best available option without considering future consequences."]}),"\n",(0,s.jsx)(n.h2,{id:"characteristics",children:"Characteristics"}),"\n",(0,s.jsx)(n.h3,{id:"-properties-of-greedy-algorithms",children:"\u2705 Properties of Greedy Algorithms"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Greedy Choice"}),": At each step, make the choice that looks best at the moment"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optimal Substructure"}),": The optimal solution contains optimal solutions to subproblems"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Irreversibility"}),": Choices made cannot be undone"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"-when-to-use",children:"\ud83c\udfaf When to Use"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Optimization problems where local choices lead to a global optimum"}),"\n",(0,s.jsx)(n.li,{children:"When you can prove the greedy strategy works"}),"\n",(0,s.jsx)(n.li,{children:"Problems with the greedy-choice property"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"classic-greedy-algorithms",children:"Classic Greedy Algorithms"}),"\n",(0,s.jsx)(n.h3,{id:"1-activity-selection-problem",children:"1. Activity Selection Problem"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Goal"}),": Select the maximum number of non-overlapping activities"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Strategy"}),": Always pick the activity that finishes earliest"]}),"\n",(0,s.jsx)(n.h3,{id:"2-huffman-coding",children:"2. Huffman Coding"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Goal"}),": Compress data using variable-length codes"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Strategy"}),": Assign shorter codes to more frequent characters"]}),"\n",(0,s.jsx)(n.h3,{id:"3-fractional-knapsack-problem",children:"3. Fractional Knapsack Problem"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Goal"}),": Maximize value in the knapsack allowing fractions of items"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Strategy"}),": Sort by value/weight and take items in order"]}),"\n",(0,s.jsx)(n.h2,{id:"general-structure",children:"General Structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def greedy_algorithm(items):\n    # 1. Sort items based on the greedy criterion\n    items.sort(key=greedy_criteria)\n    \n    result = []\n    \n    # 2. For each item, make the greedy choice\n    for item in items:\n        if is_feasible(item, result):\n            result.append(item)\n    \n    return result\n"})}),"\n",(0,s.jsx)(n.h2,{id:"advantages-and-disadvantages",children:"Advantages and Disadvantages"}),"\n",(0,s.jsx)(n.h3,{id:"-advantages",children:"\u2705 Advantages"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Simple to implement"}),": Straightforward and intuitive logic"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Efficient"}),": Usually low complexity"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Low memory usage"}),": Doesn't need to store many solutions"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"-disadvantages",children:"\u274c Disadvantages"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Doesn't always find the global optimum"}),": Can get stuck in local optima"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Hard to prove correctness"}),": You must prove the greedy strategy works"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Limited to specific problems"}),": Doesn't work for all problem types"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"differences-from-other-paradigms",children:"Differences from Other Paradigms"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Paradigm"}),(0,s.jsx)(n.th,{children:"Characteristics"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Greedy"})}),(0,s.jsx)(n.td,{children:"Local, irreversible choices"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Dynamic Programming"})}),(0,s.jsx)(n.td,{children:"Considers all possibilities, memoization"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Backtracking"})}),(0,s.jsx)(n.td,{children:"Explores all solutions, can backtrack"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"simple-example-change-making",children:"Simple Example: Change Making"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def make_change(amount, coins):\n    """\n    Returns the minimum number of coins to make change\n    (works only for canonical coin systems)\n    """\n    coins.sort(reverse=True)  # Largest to smallest\n    result = []\n    \n    for coin in coins:\n        while amount >= coin:\n            result.append(coin)\n            amount -= coin\n    \n    return result\n\n# Example\ncoins = [25, 10, 5, 1]\namount = 67\nprint(make_change(amount, coins))  # [25, 25, 10, 5, 1, 1]\n'})}),"\n",(0,s.jsx)(n.h2,{id:"-tips-for-solving-greedy-problems",children:"\ud83c\udfaf Tips for Solving Greedy Problems"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Identify the greedy choice"}),": What criterion to use for ordering/choosing?"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Prove it works"}),": Show that local choices lead to a global optimum"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Implement"}),": Sort elements and make sequential choices"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Test"}),": Check with examples if the solution is correct"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);